Require Import Ascii.
Require Import List.
Require Import String.
Require Import Ynot.
Require Import Message.
Require Import Kernel.

Open Local Scope char_scope.
Open Local Scope hprop_scope.
Open Local Scope stsepi_scope.

(* REMEMBER : traces are in reverse chrono order
 * so most recent event is in head position and
 * first action is last
 *)

Ltac inv H :=
  inversion H; subst; clear H.

Ltac uninhabit_step :=
  match goal with
  | [ H: inhabit_unpack (ktr ?s) _ = [_]%inhabited |- _ ] =>
    destruct s; simpl in *
  | [ H: inhabit_unpack ?itr _ = [_]%inhabited |- _ ] =>
    unfold itr in *
  | [ H: inhabit_unpack ?itr _ = [_]%inhabited |- _ ] =>
    destruct itr; simpl in *
  | [ H: [_]%inhabited = [_]%inhabited |- _ ] =>
    apply pack_injective in H;
    rewrite -> H in * || rewrite <- H in *
  | [ IH: forall ktr, [?ktr']%inhabited = [ktr]%inhabited -> _ |- _ ] =>
    specialize (IH ktr' (refl_equal _))
  end.

Ltac uninhabit :=
  repeat uninhabit_step.

(* if you see aft in a trace,
 * then it is immediately chrono preceded by bef
 *)
Definition ImmBefore (bef aft : KTrace) : Prop :=
  forall kst, KInvariant kst ->
  forall x y, ktr kst = [x ++ aft ++ y]%inhabited ->
  exists z, y = bef ++ z.

(* if you see bef in a trace,
 * then it is immediately chrono followed by aft
 *)
Definition ImmAfter (bef aft : KTrace) : Prop :=
  forall kst, KInvariant kst ->
  forall x y, ktr kst = [x ++ bef ++ y]%inhabited ->
  exists z, x = z ++ aft.

Definition valid_msg (m: msg) : Prop :=
  forall t, m <> BadTag t.

Ltac imm_tac_step :=
  match goal with
  | |- exists z, ?x = z ++ ?x =>
      exists nil; auto

  | H: nil = _ ++ _ :: _ |- _ =>
      apply app_cons_not_nil in H; contradiction

  | H: valid_msg (BadTag ?t) |- _ =>
      unfold valid_msg in H; edestruct H; eauto

  | H : inhabit_unpack ?tr _ = [_]%inhabited |- _ =>
      match tr with
      | ktr ?s =>
          destruct s; simpl in *
      | tr =>
          unfold tr in *; clear tr
      | tr =>
          destruct tr; simpl in *
      end

  | H: [_]%inhabited = [_]%inhabited |- _ =>
      apply pack_injective in H

  | H: _ :: _ = ?tr ++ _ |- _ =>
      destruct tr; simpl in *; inv H

  | H: ValidExchange _  _ |- _ =>
      inv H; simpl in *

  | |- exists z, ?a :: ?x = z ++ ?c =>
      let H := fresh "H" in
      let e := fresh "e" in
      cut (exists z, x = z ++ c);
        [ intro H; destruct H as [e H]; rewrite H; exists (a :: e); auto | ]

  | _ =>
      eauto
  end.

Ltac imm_tac :=
  repeat progress imm_tac_step.

(* TODO MsgPat to match on more than just tags *)

Inductive MsgPat : Set :=
(* __MSGPAT_CASES__ *)
.

Inductive MsgMatch : MsgPat -> msg -> Prop :=
(* __MSGMATCH_CASES__ *)
.

(* constrain chan in send / recv patterns *)
Inductive KActionPat : Set :=
| KAP_KSend : MsgPat -> KActionPat
| KAP_KRecv : MsgPat -> KActionPat
.

Inductive KActionMatch : KActionPat -> KAction -> Prop :=
| KAM_KSend :
  forall mp c m,
  MsgMatch mp m ->
  KActionMatch (KAP_KSend mp) (KSend c m)
| KAM_KRecv :
  forall mp c m,
  MsgMatch mp m ->
  KActionMatch (KAP_KRecv mp) (KRecv c m)
.

Inductive KTracePat : Set :=
| KTP_Empty : KTracePat
| KTP_Class : list KActionPat -> KTracePat
| KTP_NegClass : list KActionPat -> KTracePat
| KTP_Cat : KTracePat -> KTracePat -> KTracePat
| KTP_Alt : KTracePat -> KTracePat -> KTracePat
| KTP_Star : KTracePat -> KTracePat
.

Inductive KTraceMatch : KTracePat -> KTrace -> Prop :=
| KTM_Empty :
  KTraceMatch KTP_Empty nil
| KTM_Class :
  forall class kap a,
  In kap class ->
  KActionMatch kap a ->
  KTraceMatch (KTP_Class class) (a :: nil)
| KTM_NegClass :
  forall class a,
  (forall kap, In kap class -> ~ KActionMatch kap a) ->
  KTraceMatch (KTP_NegClass class) (a :: nil)
| KTM_Cat :
  forall p1 t1, KTraceMatch p1 t1 ->
  forall p2 t2, KTraceMatch p2 t2 ->
  KTraceMatch (KTP_Cat p1 p2) (t1 ++ t2)
| KTM_Alt_l :
  forall p1 p2 t, KTraceMatch p1 t ->
  KTraceMatch (KTP_Alt p1 p2) t
| KTM_Alt_r :
  forall p1 p2 t, KTraceMatch p2 t ->
  KTraceMatch (KTP_Alt p1 p2) t
| KTM_Star_0 :
  forall p,
  KTraceMatch (KTP_Star p) nil
| KTM_Star_N :
  forall p t1 t2,
  KTraceMatch p t1 ->
  KTraceMatch (KTP_Star p) t2 ->
  KTraceMatch (KTP_Star p) (t1 ++ t2)
.

Definition KTP_Any : KTracePat :=
  KTP_NegClass nil.

Lemma KTM_Any :
  forall a, KTraceMatch KTP_Any (a :: nil).
Proof.
  intros. apply KTM_NegClass; intros.
  inv H; auto.
Qed.

Definition KTP_AnyStar : KTracePat :=
  KTP_Star KTP_Any.

Lemma KTM_AnyStar :
  forall tr, KTraceMatch KTP_AnyStar tr.
Proof.
  induction tr. constructor.
  replace (a :: tr) with ((a :: nil) ++ tr) by auto.
  constructor; auto. apply KTM_Any; auto.
Qed.

Definition KTP_Single (kap : KActionPat) : KTracePat :=
  KTP_Class (kap :: nil).

Definition KTP_NegSingle (kap : KActionPat) : KTracePat :=
  KTP_NegClass (kap :: nil).

Ltac ktm_step ctac :=
  match goal with
  | [ H: KTraceMatch (KTP_Alt _ _) _ |- _ ] => inv H
  | [ H: KTraceMatch (KTP_Cat _ _) _ |- _ ] => inv H
  | [ H: (@In KActionPat ?kap (_ :: _)) |- _ ] => inv H
  | [ H: False |- _ ] => contradiction
  | [ |- ~ KActionMatch _ _ ] =>
    let H := fresh in intro H; inv H
  | [ |- KTraceMatch (KTP_Star (KTP_Class _)) (?ka :: ?kt) ] =>
    replace (ka :: kt) with ((ka :: nil) ++ kt) by auto
  | [ |- KTraceMatch (KTP_Star (KTP_NegClass _)) (?ka :: ?kt) ] =>
    replace (ka :: kt) with ((ka :: nil) ++ kt) by auto

  (* These cases either succeed or leave the goal unmodified.
   * This is to avoid unsolvable goals which can arise if we
   * fall through to apply econstructor.
   *)
  | [ |- KTraceMatch (KTP_Alt _ _) _] =>
    solve
      [ apply KTM_Alt_l; ctac
      | apply KTM_Alt_r; ctac
      ] || auto (* don't fall through *)
  | [ |- KTraceMatch (KTP_Cat _ _) (?ka :: ?kt) ] =>
    solve
      [ rewrite app_comm_cons; ctac
      | replace (ka :: kt) with ((ka :: nil) ++ kt) by auto; ctac
      ] || auto (* don't fall through *)
  | [ |- KTraceMatch (KTP_Star _) (?ka :: ?kt) ] =>
    solve
      [ replace (ka :: kt) with ((ka :: nil) ++ kt) by auto; ctac
      ] || auto (* don't fall through *)

  (* default - try constructors based on the shape of trace to match *)
  | _ =>
    econstructor; eauto; intros
  end.

Ltac ktm :=
  unfold KTP_AnyStar, KTP_Any, KTP_Single, KTP_NegSingle in *;
  repeat ktm_step ktm.

(* __PROPERTIES__ *)
