Require Import Ascii.
Require Import List.
Require Import String.
Require Import Ynot.
Require Import Message.

Open Local Scope char_scope.
Open Local Scope hprop_scope.
Open Local Scope stsepi_scope.

Inductive KAction : Set :=
| KExec   : str -> tchan -> KAction
| KCall   : str -> str -> fdesc -> KAction
| KSelect : list tchan -> tchan -> KAction
| KSend   : tchan -> msg -> KAction
| KRecv   : tchan -> msg -> KAction
.

Definition KTrace : Set :=
  list KAction.

Definition expand_kaction (ka : KAction) : Trace :=
  match ka with
  | KExec cmd c => Exec cmd c :: nil
  | KCall cmd arg pipe => Call cmd arg pipe :: nil
  | KSelect cs c => Select cs c :: nil
  | KSend c m => SendMsg c m
  | KRecv c m => RecvMsg c m
  end.

Fixpoint expand_ktrace (kt : KTrace) : Trace :=
  match kt with
  | nil => nil
  | ka :: kas => expand_kaction ka ++ expand_ktrace kas
  end.

Inductive ValidExchange : KTrace -> Prop :=
(* __VE_HANDLED_CASES__ *)
(* __VE_UNHANDLED_CASES__ *)
(* special case for errors *)
| VE_BadTag :
  forall c tag,
  ValidExchange (
    KRecv c (BadTag tag) :: nil).

Hint Constructors ValidExchange.

Inductive KTraceOK : KTrace -> Prop :=
| KT_init :
(* __KTRACE_INIT__ *)
| KT_select :
  forall tr cs c,
  KTraceOK tr ->
  KTraceOK (KSelect cs c :: tr)
| KT_exchange :
  forall tr tEx,
  KTraceOK tr ->
  ValidExchange tEx ->
  KTraceOK (tEx ++ tr).

Hint Constructors KTraceOK.

Fixpoint all_bound (cs : list tchan) : hprop :=
  match cs with
    | nil => emp
    | c :: cs' => bound c * all_bound cs'
  end.

Fixpoint all_bound_drop (cs : list tchan) (drop : tchan) : hprop :=
  match cs with
  | nil => emp
  | c :: cs' =>
    if tchan_eq c drop
      then all_bound cs'
      else bound c * all_bound_drop cs' drop
  end.

Lemma unpack_all_bound :
  forall cs c,
  In c cs ->
  all_bound cs ==> bound c * all_bound_drop cs c.
Proof.
  induction cs; simpl; intros. contradiction.
  destruct H; subst. rewrite tchan_eq_true. apply himp_refl.
  case (tchan_eq a c); intros; subst. apply himp_refl.
  apply himp_comm_conc. apply himp_assoc_conc1.
  apply himp_split. apply himp_refl.
  apply himp_comm_conc; auto.
Qed.

Lemma repack_all_bound :
  forall cs c,
  In c cs ->
  bound c * all_bound_drop cs c ==> all_bound cs.
Proof.
  induction cs; simpl; intros. contradiction.
  destruct H; subst. rewrite tchan_eq_true. apply himp_refl.
  case (tchan_eq a c); intros; subst. apply himp_refl.
  apply himp_comm_prem. apply himp_assoc_prem1.
  apply himp_split. apply himp_refl.
  apply himp_comm_prem; auto.
Qed.

Record kstate : Set :=
  mkst { components : list tchan
       ; ktr : [KTrace]
(* __KSTATE_FIELDS__ *)
       }.

Definition kstate_inv s : hprop :=
  tr :~~ ktr s in
  traced (expand_ktrace tr) * [KTraceOK tr] * all_bound (components s)
(* __KSTATE_INVS__ *)
.

Ltac unfoldr := unfold kstate_inv.

Ltac sep' := sep fail idtac.

Ltac trace_ok :=
  match goal with
  | [ _: KTraceOK ?x |- KTraceOK (_ ++ ?x) ] =>
      econstructor; [eauto|]
  | [ _: KTraceOK ?x |- KTraceOK (?w :: ?x) ] =>
      replace (w :: x) with ((w::nil) ++ x)
  | [ _: KTraceOK ?x |- KTraceOK (?u :: ?w :: ?x) ] =>
      replace (u :: w :: x) with ((u :: w::nil) ++ x)
  | [ _: KTraceOK ?x |- KTraceOK ?t ] =>
      match t with context [x] => repeat (rewrite app_assoc) end
  | [ |- ValidExchange ((_ ++ _) ++ _) ] =>
      repeat (rewrite <- app_assoc)
  | [ |- ValidExchange _ ] =>
      constructor
  end.

Ltac isolate t :=
  match t with ?lhs ==> ?rhs =>
    refine (@himp_trans (lhs * _) _ _ _ _); [ sep' | ];
    refine (@himp_trans (rhs * _) _ _ _ _); [ | sep' ];
    apply himp_split
  end.

Ltac bounds_packing :=
  match goal with

  | [ |- ?lhs ==> ?rhs ] =>
    match lhs with context [ all_bound_drop ?cs ?c ] =>
      isolate (bound c * all_bound_drop cs c ==> all_bound cs);
      [ apply repack_all_bound | ]
    end

  | [ |- ?lhs ==> ?rhs ] =>
    match rhs with context [ all_bound_drop ?cs ?c ] =>
      isolate (all_bound cs ==> bound c * all_bound_drop cs c);
      [ apply unpack_all_bound | ]
    end

  | [ |- ?lhs ==> ?rhs ] =>
    match lhs with context [ all_bound_drop ?cs ?c ] =>
    match rhs with context [ all_bound_drop ?cs ?d ] =>
      isolate (bound c * all_bound_drop cs c ==> bound d * all_bound_drop cs d);
      [ eapply himp_trans; [ apply repack_all_bound | apply unpack_all_bound ] | ]
    end
    end

  end.

Ltac simplr :=
  sep';
  try bounds_packing;
  try trace_ok.

Definition kinit :
  forall (_ : unit),
  STsep (traced nil)
        (fun s => kstate_inv s).
Proof.
  intros; refine (
(* __INIT_CODE__ *)
  );
  sep unfoldr simplr.
Qed.

(* __EXCHANGES__ *)

Fixpoint type_of_comp
  (c: tchan) (comps: list tchan): chan_type :=
  match comps with
(* __TYPE_OF_COMP_DEFAULT__ *)
  | x :: rest =>
    if tchan_eq x c
      then projT1 x
      else type_of_comp c rest
  end.

Definition kbody:
  forall s,
  STsep (kstate_inv s)
        (fun s' => kstate_inv s').
Proof.
(* __KBODY__ *)
Qed.

Definition kloop:
  forall s,
  STsep (kstate_inv s)
        (fun s' => kstate_inv s').
Proof.
  intros; refine (
    Fix
      (fun s => kstate_inv s)
      (fun s s' => kstate_inv s')
      (fun self s =>
        s <- kbody s;
        s <- self s;
        {{ Return s }}
      )
    s
  );
  sep fail auto.
Qed.

Definition main:
  forall (_ : unit),
  STsep (traced nil)
        (fun s' => kstate_inv s').
Proof.
  intros; refine (
    s0 <- kinit tt;
    sN <- kloop s0;
    {{ Return sN }}
  );
  unfold kstate_inv;
  sep fail auto.
Qed.

(* __PROPERTIES__ *)

Definition ImmBefore (bef aft : KTrace) : Prop :=
  forall tr, KTraceOK tr ->
  forall x y, tr = x ++ bef ++ y ->
  exists z, y = aft ++ z.

Definition ImmAfter (bef aft : KTrace) : Prop :=
  forall tr, KTraceOK tr ->
  forall x y, tr = x ++ aft ++ y ->
  exists z, x = z ++ bef.

Ltac inv H :=
  inversion H; subst; clear H.

Ltac imm_tac := repeat progress
  match goal with
  | |- exists z, ?x = z ++ ?x =>
    exists nil; auto
  | H: nil = ?x ++ ?y :: ?z |- _ =>
    apply app_cons_not_nil in H; contradiction
  | H: ?e :: ?tr = ?a ++ ?b |- _ =>
    destruct a; simpl in *; inv H
  | H: ValidExchange ?tr |- _ =>
    inv H; simpl in *
  | |- exists z, ?a :: ?x = z ++ ?c =>
    let H := fresh "H" in
    let e := fresh "e" in
    cut (exists z, x = z ++ c);
      [ intro H; destruct H as [e H]; rewrite H; exists (a :: e); auto | ]
  | _ =>
    eauto
  end.
